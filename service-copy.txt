const cds = require("@sap/cds");

// ============================================================================
// 🔧 UTILITY FUNCTIONS
// ============================================================================

/**
 * Extract date parameters from deeply nested query structure
 * Uses iterative depth-first search to handle arbitrary nesting
 * Required as fiori sends multiple requests with nested select and thus also where statements at different levels
 * different function for data param as required. 
 */
function extractDateParams(query, previousStartDate = null, previousEndDate = null) {
  const DEFAULT_START_DATE = '2024-10-14';
  const DEFAULT_END_DATE = '2024-10-14';
  
  let startDate = previousStartDate;
  let endDate = previousEndDate;

  const queue = [query];
  
  while (queue.length > 0) {
    const obj = queue.shift();
    
    if (!obj || typeof obj !== 'object') continue;

    // Check WHERE clause at current level
    if (Array.isArray(obj.where)) {
      for (let i = 0; i < obj.where.length; i++) {
        const condition = obj.where[i];
        
        if (condition?.ref?.[0] === 'IP_START_DATE' && obj.where[i + 2]?.val) {
          const val = obj.where[i + 2].val.trim();
          if (val) startDate = val;
        }
        
        if (condition?.ref?.[0] === 'IP_END_DATE' && obj.where[i + 2]?.val) {
          const val = obj.where[i + 2].val.trim();
          if (val) endDate = val;
        }
      }
    }

    // Add nested structures to queue
    if (obj.SELECT) queue.push(obj.SELECT);
    if (obj.from?.SELECT) queue.push(obj.from.SELECT);
    
    if (Array.isArray(obj.columns)) {
      obj.columns.forEach(col => {
        if (col.SELECT) queue.push(col.SELECT);
      });
    }
  }

  return {
    startDate: startDate?.trim() || DEFAULT_START_DATE,
    endDate: endDate?.trim() || DEFAULT_END_DATE
  };
}

/**
 * Extract all referenced fields from nested query structure
 * Returns dimensions, measures, and other fields found
 * this to aid in mapping and aggregation. by reading it from the query structure it can be reused for different entities.
 */
function extractFieldsFromQuery(query) {
  const allFields = new Set();
  const measureFields = new Set();
  const dimensionFields = new Set();

  function traverse(obj) {
    if (!obj || typeof obj !== 'object') return;

    // Extract from columns
    if (Array.isArray(obj.columns)) {
      obj.columns.forEach(col => {
        // Direct field reference
        if (col.ref) {
          const field = col.ref[0];
          allFields.add(field);
          dimensionFields.add(field);
        }
        
        // Aggregate function argument
        if (col.func && ['sum', 'avg', 'count'].includes(col.func)) {
          if (col.args?.[0]?.ref) {
            const field = col.args[0].ref[0];
            allFields.add(field);
            measureFields.add(field);
          }
        }
      });
    }

    // Extract from groupBy
    if (Array.isArray(obj.groupBy)) {
      obj.groupBy.forEach(g => {
        if (g.ref) {
          const field = g.ref[0];
          allFields.add(field);
          dimensionFields.add(field);
        }
      });
    }

    // Extract from where
    if (Array.isArray(obj.where)) {
      obj.where.forEach(w => {
        if (w?.ref) allFields.add(w.ref[0]);
      });
    }

    // Recurse into nested structures
    if (obj.SELECT) traverse(obj.SELECT);
    if (obj.from?.SELECT) traverse(obj.from.SELECT);
    if (Array.isArray(obj.columns)) {
      obj.columns.forEach(col => {
        if (col.SELECT) traverse(col.SELECT);
      });
    }
  }

  traverse(query);

  return {
    allFields: Array.from(allFields).filter(f => f !== 'ID'),
    measureFields: Array.from(measureFields),
    dimensionFields: Array.from(dimensionFields).filter(f => f !== 'ID')
  };
}

/**
 * Analyze query to determine aggregation requirements
 * Returns groupBy fields, aggregate fields, and query type flags
 */
function analyzeAggregation(query) {
  const aggregateFields = new Set();
  let groupByFields = [];
  let originalGroupByFields = [];
  let hasCountOnly = false;

  function search(obj) {
    if (!obj || typeof obj !== 'object') return;

    // Find groupBy
    if (Array.isArray(obj.groupBy)) {
      originalGroupByFields = obj.groupBy.map(g => g.ref[0]);
      groupByFields = [...originalGroupByFields];
    }

    // Find aggregate functions
    if (Array.isArray(obj.columns)) {
      obj.columns.forEach(col => {
        if (col.func === 'count') {
          hasCountOnly = true;
        } else if (['sum', 'avg'].includes(col.func)) {
          const field = col.args?.[0]?.ref?.[0];
          if (field) aggregateFields.add(field);
        }
      });
    }

    // Recurse
    if (obj.SELECT) search(obj.SELECT);
    if (obj.from?.SELECT) search(obj.from.SELECT);
  }

  search(query);

  // Filter out ID from groupBy, else always treated as detail
  groupByFields = groupByFields.filter(f => f !== 'ID');

  const includesIdInGroupBy = originalGroupByFields.includes('ID');
  const isCountOnlyQuery = hasCountOnly && aggregateFields.size === 0;
  const needsAggregation = aggregateFields.size > 0;

  return {
    groupByFields,
    aggregateFields: Array.from(aggregateFields),
    isCountOnlyQuery,
    includesIdInGroupBy,
    needsAggregation
  };
}

/**
 * Perform manual aggregation on data
 * Groups by specified fields and sums measures
 */
function aggregateData(data, groupByFields, aggregateFields) {
  const groups = {};
  
  data.forEach(item => {
    const key = groupByFields.map(f => item[f] || '').join('|');
    
    if (!groups[key]) {
      groups[key] = {
        ID: cds.utils.uuid(),
        ...Object.fromEntries(groupByFields.map(f => [f, item[f]])),
        ...Object.fromEntries(aggregateFields.map(f => [f, 0]))
      };
    }
    
    aggregateFields.forEach(f => {
      groups[key][f] += parseFloat(item[f]) || 0;
    });
  });
  
  return Object.values(groups);
}

/**
 * Define static field mapping for entity
 * This should be entity-specific and define all fields, required for aggregation
 * if new entity is required this is where to add it.
 * Then implement the logic in the CAP service handler. 
 */
const ENTITY_FIELD_MAPPINGS = {
  PosAnalyticsDSP: {
    dateFields: ['IP_START_DATE', 'IP_END_DATE', '_0CALDAY_1'],
    measures: [
      'CK_SALES_QUANTITY',
      '_0RPA_CNR',
      '_0RPA_NSA',
      '_0RPA_SAT',
      '_0RPA_TAM',
      '_0RPA_TAT',
      'ZRPA_NDA'
    ],
    dimensions: [
      '_0PLANT_1',
      '_0SALESORG_1',
      '_0MATERIAL_1',
      '_0MATERIAL_T',
      '_0BASE_UOM',
      '_0CALMONTH',
      '_0CALQUARTER',
      '_0CALWEEK',
      '_0CALYEAR',
      '_0FISCPER',
      '_0FISCPER3',
      '_0FISCVARNT',
      '_0FISCYEAR',
      '_0RT_SALHOUR',
      'ZSALTIME',
      '_0CURRENCY',
      '_0DOC_CURRCY',
      '_0LOC_CURRCY',
      '_0RPA_TIX',
      '_0RPA_TNR',
      '_0RPA_WID',
      'ZTNR_DAY',
      '_0RPA_WGH1',
      '_0RPA_WGH2',
      '_0RPA_WGH3',
      '_0RPA_WGH4',
      'CC_INFOPROVIDER'
    ]
  }
};

/**
 * Map raw Datasphere data to internal structure
 * Always maps ALL fields to ensure aggregation works at any level
 */
function mapDatasphereRecord(item, entityName, startDate, endDate) {
  const mapping = ENTITY_FIELD_MAPPINGS[entityName];
  
  if (!mapping) {
    throw new Error(`No field mapping defined for entity: ${entityName}`);
  }

  const record = {
    ID: cds.utils.uuid()
  };

  // Map date fields
  mapping.dateFields.forEach(field => {
    if (field === 'IP_START_DATE') {
      record[field] = startDate;
    } else if (field === 'IP_END_DATE') {
      record[field] = endDate;
    } else {
      record[field] = item[field];
    }
  });

  // Map measures (ensure numeric)
  mapping.measures.forEach(field => {
    record[field] = parseFloat(item[field]) || 0;
  });

  // Map dimensions
  mapping.dimensions.forEach(field => {
    record[field] = item[field];
  });

  return record;
}

// ============================================================================
// 🚀 CAP SERVICE IMPLEMENTATION
// ============================================================================

module.exports = class DSService extends cds.ApplicationService {
  constructor() {
    super(...arguments);
    this.lastStartDate = null;
    this.lastEndDate = null;
    this.rawDataCache = new Map();
  }

  async init() {
    const datasphere = await cds.connect.to('datasphere');

    this.on("READ", "PosAnalyticsDSP", async (req) => {
      console.log("\n=== DSService - PosAnalyticsDSP Request ===");
      console.log('Query:', JSON.stringify(req.query, null, 2));

      // 📅 Extract date parameters
      const { startDate, endDate } = extractDateParams(
        req.query, 
        this.lastStartDate, 
        this.lastEndDate
      );
      
      this.lastStartDate = startDate;
      this.lastEndDate = endDate;
      console.log(`Date range: ${startDate} to ${endDate}`);

      const cacheKey = `${startDate}|${endDate}`;

      // 📦 Fetch and cache raw data from Datasphere
      if (!this.rawDataCache.has(cacheKey)) {
        console.log('⬇️  Fetching data from Datasphere...');
        
        const results = await datasphere.send(
          "GET",
          `POS/4AM_POS_01/_4AM_POS_01(IP_START_DATE=${startDate},IP_END_DATE=${endDate})/Set`,
          { headers: {} }
        );

        console.log(`✅ Retrieved ${results.length} records from Datasphere`);

        // Map ALL fields (not just query fields) to support any aggregation level
        const mappedResults = results.map(item => 
          mapDatasphereRecord(item, 'PosAnalyticsDSP', startDate, endDate)
        );

        this.rawDataCache.set(cacheKey, mappedResults);
        console.log(`💾 Cached ${mappedResults.length} records`);
      } else {
        console.log('✅ Using cached data');
      }

      let data = [...this.rawDataCache.get(cacheKey)];

      // 📊 Analyze query for aggregation needs
      const {
        groupByFields,
        aggregateFields,
        isCountOnlyQuery,
        includesIdInGroupBy,
        needsAggregation
      } = analyzeAggregation(req.query);

      console.log('📊 Aggregation analysis:', {
        needsAggregation,
        isCountOnlyQuery,
        includesIdInGroupBy,
        groupByFields,
        aggregateFields
      });

      // 🔄 Perform aggregation if needed
      if (needsAggregation && !isCountOnlyQuery) {
        if (groupByFields.length === 0) {
          console.log('📈 Creating grand total (no groupBy)');
          
          const totals = { ID: cds.utils.uuid() };
          aggregateFields.forEach(field => {
            totals[field] = data.reduce((sum, item) => 
              sum + (parseFloat(item[field]) || 0), 0
            );
          });
          
          data = [totals];
          console.log('Grand total:', totals);
        } else {
          console.log(`📊 Aggregating by: [${groupByFields.join(', ')}]`);
          
          const beforeCount = data.length;
          data = aggregateData(data, groupByFields, aggregateFields);
          
          console.log(`✅ Aggregated ${beforeCount} → ${data.length} records`);
          if (data.length > 0) {
            console.log('Sample:', data[0]);
          }
        }
      } else if (isCountOnlyQuery) {
        console.log('🔢 Count-only query - returning data as-is');
      } else {
        console.log('📄 Returning raw detail records');
      }

      console.log(`✅ Returning ${data.length} records\n`);
      return data;
    });

    await super.init();
  }
};
